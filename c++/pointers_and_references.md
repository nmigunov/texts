# Указатели, ссылки и динамическая память
Указатели, ссылки и динамическая память - самые мощные особенности языков C/C++, которые позволяют программисту напрямую работать с памятью - самым критическим и дефицитным ресурсом в компьютере - для улучшения производительности. Однако указатели также являются самой сложной особенностью языков C/C++.

Указатели очень мощны, потому что дают возможность обращаться к адресам памяти и работать с их содержимым. Но они также сложны в обращении. Если использовать их правильно, они могут увеличить эффективность и производительность программы. С другой стороны неправильное использование может привести ко многим проблемам: утечки памяти и переполнение буфера - данные баги могут привести к ухудшению безопасности вашей программы. Во многих новых (относительно) языках (например, Java и C#) указатели были удалены, чтобы избежать проблем с памятью.

Хотя вы можете писать на C++ без использования указателей, однако сложно не упомянуть их во время обучения языку C++.

## Указатели
Место в компьютерной памяти имеет *адрес* и *содержимое*. Адрес - это число (обычно шестнадцатеричное), с которым трудно работать на прямую. Обычно, каждый адрес содержит 8 бит (1 байт) данных. То, как интерпретировать данные (являются ли они числом, символом или строкой) полностью зависит от программиста.

Чтобы облегчить программирование, используя численные адреса и зависящие от программиста интерпретации, в ранних языках программирования (например, C) был представлен концепт переменных. Переменная - это *именованная* область памяти, которая может содержать значение определенного типа. Вместо численного адреса, были использованы имена, которые были привязаны к определенному адресу. Также, типы (int, double, char) были связаны с содержимым для простой интерпретации данных.

Каждый адрес обычно содержит 8 бит данных. Значение типа int (4 байта) занимает 4 ячейки памяти. На 32 битных системах обычно используются 32 битные адреса. Чтобы поместить 32-х битный адрес, нужно 4 ячейки памяти.

Следующая диаграмма иллюстрирует отношения между адресом и содержимым компьютерной памяти; и именем переменной, ее типом и значением, которое используется программистами.
![Диаграмма](https://www.ntu.edu.sg/home/ehchua/programming/cpp/images/MemoryAddressContent.png)

### Указатели, как переменные
*Переменная указателя* - это та же самая переменная, только она содержит адрес, а не значение.

### Обозначение указателей
Указатели должны быть обозначены перед использованием. Синтаксис обозначения указателя включает в себя * перед именем. Указатель также ассоциируется с типом:

```
type *ptr;
// или
type* ptr;
```

Например:
```c++
int *iPtr;
double *dPtr;
```
Запомните, что вы должны ставить * перед именем каждого указателя. * - не оператор, символ указывает на то, что после имени идет указатель, а не обычная переменная.
```c++
int *p1, *p2, i; // p1 и p2 указатели, а i просто int
int* p1, p2, i; // p1 - указатель, а p2 и i - просто int
```

### Инициализация указателей с помощью оператора &
Когда вы обозначаете указатель, его содержимое не инициализировано. Говоря по другому, он содержит адрес "где-то там", который, очевидно, является неправильным положением. Это опасно! Вам нужно инициализировать указатель, присваивая ему правильный адрес. Обычно это делается с помощью оператора & (взять адрес).

Данный оператор работает с переменной и возвращает ее адрес. Например, если `number` - это переменная типа `int`, то `&number` вернет адрес переменной `number`.

Вы можете использовать оператор, чтобы получить адрес переменной и присвоить его указателю.
```c++
int number = 88;  // Переменная типа int
int *pNumber;     // Обозначение указателя типа int
pNumber = &number; // Присвоение адреса переменной number указателю pNumber
```

![diag](https://www.ntu.edu.sg/home/ehchua/programming/cpp/images/PointerDeclaration.png)

Как можно заметить, переменная `number` типа int, начинается на адресе 0x22ccec и содержит значение 88. Выражение `&number` возвращает адрес переменной, которым является 0x22ccec. Затем адрес присваивается указателю `pNumber`.

Оператор & может быть использован только на RHS (right hand side).

### Косвенный или Оператор разыменовывания (\*)
Оператор разыменовывания (\*) работает с указателем и возвращает значение, которое хранится по адресу указателя. Например, если `pNumber` - это указатель int, то `*pNumber` вернет значение по данному адресу.

```c++
int number = 88;
int *pNumber = &number;   // Обозначить и присваевается адрес переменной number
cout << pNumber << endl;  // Напечатает адрес, на который указывает
cout << *pNumber << endl; // Напечатает значение адреса, на который указывает (88)
*pNumber = 99;            // Присвоить новое значение pNumber, а также изменить данные по адресу, на который указывает pNumber
cout << *pNumber << endl; // Новое значение (99)
cout << number << endl;   // Значение переменной number также изменится
```

Заметьте, что `pNumber` содержит адрес в памяти, в то время как `*pNumber` указывает на значение по данному адресу.

Как было показано, переменная (`number`) напрямую "общается" со значением, а указатель "общается" через адрес в памяти, на который он указывает.

Разыменовывающий оператор может быть использован как на RHS (`temp = *pNumber`), так и на LHS (`*pNumber = 99`).

Запомните, что символ \* имеет разные значения в объявлении и выражении. Когда он использован в объявлении (`int *pNumber`), то это означает, что `pNumber` - указатель. В то время как в выражении (`*pNumber = 99; temp << *pNumber;`), то это обозначает, что используется значение, которое находится по адресу.

### У указателя тоже есть тип
Указатель, соединен с типом (значения, на которое указывает), который указывается при объявлении. Указатель может содержать только адрес объявленного типа.
```c++
int i = 88;
double d = 55.66;
int * iPtr = &i;    // указатель типа int
double * dPtr = &d; // указатель типа double
 
iPtr = &d;   // ОШИБКА, указатель iPtr не может содержать значение другого типа
dPtr = &i;   // ОШИБКА
iPtr = i;    // ОШИБКА, указатель содержит адрес, а не значение
 
int j = 99;
iPtr = &j;  // Вы можете изменять адрес, который содержит указатель
```

### Не инициализированные указатели
Данный код имеет серьезную логическую ошибку
```c++
int * iPtr;
*iPtr = 55;
cout << *iPtr << endl;
```
Указатель `iPtr` был объявлен без инициализации, то есть он указывает "куда-то" (случайное место в памяти). Выражение `*iPtr = 55;` "ломает" значение этого "куда-то"! Вам нужно инициализировать указатель каким-либо правильным адресом. Большинство компиляторов пройдут мимо и не укажут вам на не инициализированный указатель!

### Указатели NULL
Вы можете инициализировать указатель 0 или NULL, то есть, чтобы он ни на что не указывал. Это называется указатель NULL (NULL pointer). Разыменовывание нулевого указателя вызывает исключение (ошибку) STATUS_ACCESS_VIOLATION.
```c++
int *iPtr = 0;         // Объявление указателя
cout << *iPtr << endl; // ОШИБКА! STATUS_ACCESS_VIOLATION

int *p = NULL;         // Также объявление указателя на пустоту
```

Инициализировать указатель нулем - хорошая практика в программировании.

Совет переводчика: Так как на дворе 2017 год, то уже все компиляторы поддерживают C++11 по умолчанию. В C++11 было введено много интересных нововведений, одно из них - `nullptr`. Это замена обычному `NULL`. В то время как `NULL` - это просто алиас для 0, `nullptr` - это специально созданный типа. Поэтому настоятельно рекомендуется использовать `nullptr`.

## Ссылочные переменные
TODO
